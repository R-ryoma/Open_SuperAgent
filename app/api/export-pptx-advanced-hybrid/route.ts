import { NextRequest, NextResponse } from 'next/server';
import PptxGenJS from 'pptxgenjs';
import puppeteer from 'puppeteer';

interface SlideData {
  html: string;
  index: number;
}

// ハイブリッドアプローチでPPTXを生成
export async function POST(request: NextRequest) {
  let browser: puppeteer.Browser | null = null;
  
  try {
    const body = await request.json();
    const { slides, title = 'プレゼンテーション' } = body;
    
    if (!slides || !Array.isArray(slides) || slides.length === 0) {
      return NextResponse.json(
        { error: 'スライドHTMLが提供されていません' },
        { status: 400 }
      );
    }
    
    console.log('Starting hybrid PPTX generation...');
    
    // Puppeteerを起動
    browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    
    // PPTXオブジェクトを作成
    const pptx = new PptxGenJS();
    pptx.author = 'AI Agent';
    pptx.company = 'Generated by AI';
    pptx.title = title;
    pptx.defineLayout({ name: 'LAYOUT_16x9', width: 10, height: 5.625 });
    pptx.layout = 'LAYOUT_16x9';
    
    // 各スライドを処理
    for (const slideData of slides) {
      console.log(`Processing slide ${slideData.index} with hybrid approach...`);
      const slide = pptx.addSlide();
      
      // ページを作成
      const page = await browser.newPage();
      await page.setViewport({ width: 1280, height: 720 });
      
      try {
        // HTMLをレンダリング
        await page.setContent(`
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="UTF-8">
            <style>
              body { margin: 0; padding: 0; overflow: hidden; }
              ${slideData.html.match(/<style[^>]*>([\s\S]*?)<\/style>/gi)?.join('\n') || ''}
            </style>
          </head>
          <body>
            ${slideData.html.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')}
          </body>
          </html>
        `, { waitUntil: 'networkidle0' });
        
        await page.waitForTimeout(1000);
        
        // 1. 背景画像を生成（複雑なレイアウトやSVGを含む）
        const backgroundImage = await page.screenshot({
          type: 'png',
          encoding: 'base64',
          omitBackground: false
        });
        
        // 背景として画像を配置
        slide.addImage({
          data: `data:image/png;base64,${backgroundImage}`,
          x: 0,
          y: 0,
          w: 10,
          h: 5.625,
          sizing: { type: 'contain' }
        });
        
        // 2. テキスト要素を抽出して編集可能なテキストとして追加
        const textElements = await page.evaluate(() => {
          const texts: any[] = [];
          
          // テキスト要素を検索
          const selectors = ['h1', 'h2', 'h3', 'p', 'li', 'span'];
          
          selectors.forEach(selector => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(element => {
              // 子要素を持たないテキストのみを対象
              if (element.children.length === 0 && element.textContent?.trim()) {
                const rect = element.getBoundingClientRect();
                const style = window.getComputedStyle(element);
                
                // 透明でない要素のみ
                if (style.opacity !== '0' && style.visibility !== 'hidden') {
                  texts.push({
                    content: element.textContent.trim(),
                    bounds: {
                      x: rect.left / 128, // 1280px → 10インチ
                      y: rect.top / 128,  // 720px → 5.625インチ  
                      width: rect.width / 128,
                      height: rect.height / 128
                    },
                    style: {
                      fontSize: parseInt(style.fontSize),
                      color: style.color,
                      fontWeight: style.fontWeight,
                      textAlign: style.textAlign,
                      fontFamily: style.fontFamily
                    },
                    tagName: element.tagName.toLowerCase()
                  });
                }
              }
            });
          });
          
          return texts;
        });
        
        // 3. 主要なテキスト要素を透明な編集可能テキストとして重ねる
        for (const textElement of textElements) {
          // タイトルや重要なテキストのみを編集可能にする
          if (textElement.tagName === 'h1' || textElement.tagName === 'h2' || 
              textElement.tagName === 'h3' || 
              (textElement.tagName === 'p' && textElement.content.length > 20)) {
            
            slide.addText(textElement.content, {
              x: textElement.bounds.x,
              y: textElement.bounds.y,
              w: textElement.bounds.width,
              h: textElement.bounds.height,
              fontSize: textElement.style.fontSize || 14,
              color: rgbToHex(textElement.style.color || 'rgb(0,0,0)'),
              bold: textElement.style.fontWeight === 'bold' || 
                    parseInt(textElement.style.fontWeight) >= 700,
              align: getAlignment(textElement.style.textAlign),
              fontFace: 'Arial',
              fill: { color: 'FFFFFF', transparency: 100 }, // 完全に透明
              line: { width: 0 }
            });
          }
        }
        
        // 4. 特定の要素（ボタンなど）をクリッカブルな形状として追加
        const interactiveElements = await page.evaluate(() => {
          const elements: any[] = [];
          
          // ボタンやリンクを検索
          const buttons = document.querySelectorAll('button, a, .button, .btn');
          buttons.forEach(button => {
            const rect = button.getBoundingClientRect();
            const style = window.getComputedStyle(button);
            
            if (style.opacity !== '0' && style.visibility !== 'hidden') {
              elements.push({
                bounds: {
                  x: rect.left / 128,
                  y: rect.top / 128,
                  width: rect.width / 128,
                  height: rect.height / 128
                },
                backgroundColor: style.backgroundColor,
                borderRadius: parseInt(style.borderRadius) || 0,
                href: button.getAttribute('href') || ''
              });
            }
          });
          
          return elements;
        });
        
        // インタラクティブ要素を透明な形状として追加
        for (const element of interactiveElements) {
          if (element.href) {
            slide.addShape('rect', {
              x: element.bounds.x,
              y: element.bounds.y,
              w: element.bounds.width,
              h: element.bounds.height,
              fill: { color: 'FFFFFF', transparency: 100 },
              line: { width: 0 },
              hyperlink: { url: element.href }
            });
          }
        }
        
      } finally {
        await page.close();
      }
    }
    
    // PPTXファイルを生成
    const pptxBlob = await pptx.write({ outputType: 'blob' }) as Blob;
    const arrayBuffer = await pptxBlob.arrayBuffer();
    
    return new NextResponse(arrayBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
        'Content-Disposition': `attachment; filename="${title.replace(/[^a-z0-9]/gi, '_')}_hybrid.pptx"`,
      },
    });
    
  } catch (error) {
    console.error('Hybrid PPTX export error:', error);
    return NextResponse.json(
      { error: 'PPTXファイルの生成に失敗しました', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}

// RGB色をHEXに変換
function rgbToHex(rgb: string): string {
  if (rgb.startsWith('#')) {
    return rgb.substring(1);
  }
  
  const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
  if (match) {
    const r = parseInt(match[1]).toString(16).padStart(2, '0');
    const g = parseInt(match[2]).toString(16).padStart(2, '0');
    const b = parseInt(match[3]).toString(16).padStart(2, '0');
    return r + g + b;
  }
  
  return '000000';
}

// テキストアライメントを変換
function getAlignment(textAlign: string): 'left' | 'center' | 'right' {
  switch (textAlign) {
    case 'center':
      return 'center';
    case 'right':
      return 'right';
    default:
      return 'left';
  }
} 