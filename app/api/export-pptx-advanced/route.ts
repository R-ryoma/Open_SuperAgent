import { NextRequest, NextResponse } from 'next/server';
import PptxGenJS from 'pptxgenjs';
import { JSDOM } from 'jsdom';
import puppeteer from 'puppeteer';

interface SlideData {
  html: string;
  index: number;
}

interface ElementInfo {
  type: 'text' | 'shape' | 'image' | 'container';
  content?: string;
  bounds: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  style: {
    color?: string;
    backgroundColor?: string;
    fontSize?: number;
    fontWeight?: string;
    borderColor?: string;
    borderWidth?: number;
  };
  children?: ElementInfo[];
}

// 要素の種類と変換ルール
interface ElementRule {
  selector: string;
  handler: (element: Element, slide: any, dom: JSDOM) => void;
}

// サーバーサイドでHTMLを解析してネイティブPPTX要素に変換（改善版）
export async function POST(request: NextRequest) {
  let browser: puppeteer.Browser | null = null;
  
  try {
    const body = await request.json();
    const { slides, title = 'プレゼンテーション', useAdvancedCapture = true } = body;
    
    if (!slides || !Array.isArray(slides) || slides.length === 0) {
      return NextResponse.json(
        { error: 'スライドHTMLが提供されていません' },
        { status: 400 }
      );
    }
    
    // PPTXオブジェクトを作成
    const pptx = new PptxGenJS();
    
    // プレゼンテーションのメタデータ設定
    pptx.author = 'AI Agent';
    pptx.company = 'Generated by AI';
    pptx.title = title;
    
    // スライドサイズを16:9に設定（1280x720pxを10x5.625インチに変換）
    pptx.defineLayout({ name: 'LAYOUT_16x9', width: 10, height: 5.625 });
    pptx.layout = 'LAYOUT_16x9';
    
    if (useAdvancedCapture) {
      // Puppeteerを使用した高精度変換
      console.log('Starting Puppeteer for advanced capture...');
      browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
      });
      
      for (const slideData of slides) {
        console.log(`Processing slide ${slideData.index} with Puppeteer...`);
        const slide = pptx.addSlide();
        
        // Puppeteerで要素情報を取得
        const elementInfoList = await captureElementsWithPuppeteer(browser, slideData.html);
        
        // 取得した要素情報をPPTXに変換
        await renderElementsToPptx(slide, elementInfoList);
      }
      
    } else {
      // 従来のJSDOMベースの処理（フォールバック）
      for (const slideData of slides) {
        const slide = pptx.addSlide();
        const dom = new JSDOM(slideData.html);
        await processWithJsdom(slide, dom);
      }
    }
    
    // PPTXファイルをバイナリとして生成
    const pptxBlob = await pptx.write({ outputType: 'blob' }) as Blob;
    
    // ArrayBufferに変換
    const arrayBuffer = await pptxBlob.arrayBuffer();
    
    // レスポンスヘッダーを設定してファイルを返す
    return new NextResponse(arrayBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
        'Content-Disposition': `attachment; filename="${title.replace(/[^a-z0-9]/gi, '_')}.pptx"`,
      },
    });
    
  } catch (error) {
    console.error('Advanced PPTX export error:', error);
    return NextResponse.json(
      { error: 'PPTXファイルの生成に失敗しました', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}

// Puppeteerを使用して要素情報を正確に取得
async function captureElementsWithPuppeteer(browser: puppeteer.Browser, html: string): Promise<ElementInfo[]> {
  const page = await browser.newPage();
  
  try {
    // ビューポートを設定（1280x720のスライドサイズに合わせる）
    await page.setViewport({ width: 1280, height: 720 });
    
    // HTMLコンテンツを設定
    await page.setContent(`
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <style>
          body { margin: 0; padding: 0; }
          ${html.match(/<style[^>]*>([\s\S]*?)<\/style>/gi)?.join('\n') || ''}
        </style>
      </head>
      <body>
        ${html.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')}
      </body>
      </html>
    `, { waitUntil: 'networkidle0' });
    
    // ページが完全に読み込まれるまで待機
    await page.waitForTimeout(500);
    
    // ブラウザコンテキストで要素情報を収集
    const elementInfoList = await page.evaluate(() => {
      const elements: any[] = [];
      
      // スライドコンテナを探す
      const slideContainer = document.querySelector('.slide-container') || 
                           document.querySelector('[class*="slide"]') ||
                           document.body;
      
      if (!slideContainer) return elements;
      
      // 要素情報を再帰的に収集する関数
      function collectElementInfo(element: Element, parentBounds?: DOMRect): any {
        const bounds = element.getBoundingClientRect();
        const computedStyle = window.getComputedStyle(element);
        
        // ピクセルをインチに変換（96 DPI基準）
        const pxToInch = (px: number) => px / 96;
        
        const elementInfo: any = {
          type: determineElementType(element),
          bounds: {
            x: pxToInch(bounds.left),
            y: pxToInch(bounds.top),
            width: pxToInch(bounds.width),
            height: pxToInch(bounds.height)
          },
          style: {
            color: computedStyle.color,
            backgroundColor: computedStyle.backgroundColor,
            fontSize: parseInt(computedStyle.fontSize),
            fontWeight: computedStyle.fontWeight,
            borderColor: computedStyle.borderColor,
            borderWidth: parseInt(computedStyle.borderWidth)
          }
        };
        
        // テキストコンテンツを取得
        if (element.children.length === 0 && element.textContent?.trim()) {
          elementInfo.content = element.textContent.trim();
        }
        
        // タグ名とクラスを保存
        elementInfo.tagName = element.tagName.toLowerCase();
        elementInfo.className = element.className;
        
        // 子要素を処理
        if (element.children.length > 0) {
          elementInfo.children = [];
          for (const child of Array.from(element.children)) {
            const childInfo = collectElementInfo(child, bounds);
            if (childInfo) {
              elementInfo.children.push(childInfo);
            }
          }
        }
        
        // SVG要素の特別処理
        if (element.tagName.toLowerCase() === 'svg') {
          elementInfo.svgContent = element.outerHTML;
        }
        
        return elementInfo;
      }
      
      // 要素タイプを判定
      function determineElementType(element: Element): string {
        const tagName = element.tagName.toLowerCase();
        const className = element.className.toString().toLowerCase();
        
        if (tagName === 'h1' || tagName === 'h2' || tagName === 'h3' || 
            tagName === 'p' || tagName === 'span' || tagName === 'li') {
          return 'text';
        }
        
        if (tagName === 'svg' || className.includes('diagram') || 
            className.includes('chart') || className.includes('graph')) {
          return 'image';
        }
        
        if (className.includes('box') || className.includes('card') || 
            className.includes('container')) {
          return 'container';
        }
        
        return 'shape';
      }
      
      // ルート要素から開始
      return [collectElementInfo(slideContainer)];
    });
    
    return elementInfoList;
    
  } finally {
    await page.close();
  }
}

// 取得した要素情報をPPTXにレンダリング
async function renderElementsToPptx(slide: any, elements: ElementInfo[]) {
  for (const element of elements) {
    await renderElement(slide, element);
  }
}

// 個別の要素をレンダリング
async function renderElement(slide: any, element: ElementInfo, parentOffset = { x: 0, y: 0 }) {
  const { bounds, style, type, content } = element;
  
  // 座標をスライドサイズに合わせて調整（1280x720px → 10x5.625インチ）
  const x = bounds.x + parentOffset.x;
  const y = bounds.y + parentOffset.y;
  
  switch (type) {
    case 'text':
      if (content) {
        // テキスト要素を追加
        slide.addText(content, {
          x: x,
          y: y,
          w: bounds.width,
          h: bounds.height,
          fontSize: style.fontSize || 14,
          color: rgbToHex(style.color || 'rgb(0,0,0)'),
          bold: style.fontWeight === 'bold' || parseInt(style.fontWeight || '400') >= 700,
          fontFace: 'Arial',
          align: determineAlignment(element),
          valign: 'middle',
          wrap: true
        });
      }
      break;
      
    case 'container':
      // コンテナ要素（背景付きボックスなど）
      if (style.backgroundColor && style.backgroundColor !== 'transparent' && 
          style.backgroundColor !== 'rgba(0, 0, 0, 0)') {
        slide.addShape('rect', {
          x: x,
          y: y,
          w: bounds.width,
          h: bounds.height,
          fill: { color: rgbToHex(style.backgroundColor) },
          line: style.borderWidth && style.borderWidth > 0 ? {
            color: rgbToHex(style.borderColor || '#000000'),
            width: style.borderWidth
          } : { width: 0 }
        });
      }
      break;
      
    case 'image':
      // SVGや複雑な図形は後で画像として処理
      // ここでは位置のプレースホルダーを作成
      slide.addShape('rect', {
        x: x,
        y: y,
        w: bounds.width,
        h: bounds.height,
        fill: { color: 'F0F0F0' },
        line: { color: 'CCCCCC', width: 1 }
      });
      
      slide.addText('[図形]', {
        x: x,
        y: y + bounds.height / 2 - 0.2,
        w: bounds.width,
        h: 0.4,
        fontSize: 12,
        color: '666666',
        align: 'center'
      });
      break;
  }
  
  // 子要素を処理
  if (element.children) {
    for (const child of element.children) {
      await renderElement(slide, child, { x: x, y: y });
    }
  }
}

// アライメントを判定
function determineAlignment(element: any): 'left' | 'center' | 'right' {
  const className = element.className || '';
  const tagName = element.tagName || '';
  
  if (className.includes('center') || tagName === 'h1' || tagName === 'h2') {
    return 'center';
  }
  
  if (className.includes('right')) {
    return 'right';
  }
  
  return 'left';
}

// 従来のJSDOMベースの処理（フォールバック用）
async function processWithJsdom(slide: any, dom: JSDOM) {
  const document = dom.window.document;
  const slideContainer = document.querySelector('.slide-container') || document.body;
  
  // 簡易的な処理
  const title = slideContainer.querySelector('h1, h2');
  if (title) {
    slide.addText(title.textContent || '', {
      x: 0.5,
      y: 0.5,
      w: 9,
      h: 1,
      fontSize: 36,
      color: '0056B1',
      bold: true,
      align: 'center'
    });
  }
}

// 背景処理（改善版）
function processBackground(slide: any, container: Element, dom: JSDOM) {
  try {
    // スタイル属性から直接背景を取得
    const inlineStyle = container.getAttribute('style') || '';
    const bgMatch = inlineStyle.match(/background:\s*([^;]+)/i) || 
                   inlineStyle.match(/background-color:\s*([^;]+)/i);
    
    if (bgMatch) {
      const bgValue = bgMatch[1].trim();
      const bgColor = extractBackgroundColor(bgValue);
      if (bgColor) {
        slide.background = { color: bgColor };
        return;
      }
    }
    
    // クラス名から背景色を推定
    const classList = container.className;
    if (classList.includes('bg-gradient') || classList.includes('background')) {
      // デフォルトのグラデーション背景
      slide.background = { color: 'F5F7FA' };
    }
  } catch (error) {
    console.log('Background processing error:', error);
    // デフォルト背景
    slide.background = { color: 'FFFFFF' };
  }
}

// 構造化された要素の処理
function processStructuredElements(slide: any, container: Element, dom: JSDOM) {
  console.log('Processing structured elements...');
  
  // ヘッダー要素の処理
  const header = container.querySelector('.slide-header, [data-position="top"]');
  if (header) {
    console.log('Processing header...');
    processHeaderElements(slide, header, dom);
  } else {
    console.log('No header found, looking for title in container...');
    // ヘッダーがない場合、コンテナ内でタイトルを探す
    processHeaderElements(slide, container, dom);
  }
  
  // ボディ要素の処理
  const body = container.querySelector('.slide-body') || container;
  const bodyLayout = body.getAttribute('data-layout') || detectLayoutType(body);
  console.log('Body layout:', bodyLayout);
  
  switch (bodyLayout) {
    case 'two-column':
      processTwoColumnLayout(slide, body, dom);
      break;
    case 'grid':
      processGridLayout(slide, body, dom);
      break;
    default:
      processDefaultLayout(slide, body, dom);
  }
  
  // フッター要素の処理
  const footer = container.querySelector('.slide-footer, [data-position="bottom"]');
  if (footer) {
    console.log('Processing footer...');
    processFooterElements(slide, footer, dom);
  }
}

// ヘッダー要素の処理（改善版）
function processHeaderElements(slide: any, header: Element, dom: JSDOM) {
  // より広範なセレクタでタイトルを探す
  const title = header.querySelector('.slide-title, h1, h2, [data-element-type="title"]') ||
               header.querySelector('[class*="title"]');
               
  if (title) {
    const text = title.textContent?.trim() || '';
    
    // スタイル情報の取得（インラインスタイルも考慮）
    const inlineStyle = title.getAttribute('style') || '';
    let fontSize = 44;
    let color = '0056B1'; // デフォルトの青色
    
    // フォントサイズの取得
    const fontSizeMatch = inlineStyle.match(/font-size:\s*(\d+)/i);
    if (fontSizeMatch) {
      fontSize = parseInt(fontSizeMatch[1]);
    } else if (title.tagName === 'H1') {
      fontSize = 48;
    } else if (title.tagName === 'H2') {
      fontSize = 36;
    }
    
    // 色の取得
    const colorMatch = inlineStyle.match(/color:\s*([^;]+)/i);
    if (colorMatch) {
      color = rgbToHex(colorMatch[1].trim());
    }
    
    slide.addText(text, {
      x: 0.5,
      y: 0.5,
      w: 9,
      h: 1,
      fontSize: fontSize,
      color: color,
      bold: true,
      align: 'center',
      fontFace: 'Arial',
      wrap: true,
    });
  }
}

// レイアウトタイプを自動検出
function detectLayoutType(container: Element): string {
  // グリッドレイアウトの検出
  const bodyElement = container.querySelector('.slide-body') || container;
  const computedStyle = container.ownerDocument?.defaultView?.getComputedStyle(bodyElement);
  
  if (computedStyle?.display === 'grid' && computedStyle?.gridTemplateColumns?.includes('1fr 1fr')) {
    return 'two-column';
  }
  
  // カラムの存在をチェック
  const hasColumns = container.querySelector('.left-column, .right-column, .column-left, .column-right');
  if (hasColumns) {
    return 'two-column';
  }
  
  return 'default';
}

// 2カラムレイアウトの処理（セレクタを改善）
function processTwoColumnLayout(slide: any, body: Element, dom: JSDOM) {
  // より柔軟なセレクタで左右のカラムを探す
  const leftColumn = body.querySelector('.left-column, .column-left, [data-width="50%"]:first-child, .slide-body > div:first-child');
  const rightColumn = body.querySelector('.right-column, .column-right, [data-width="50%"]:last-child, .slide-body > div:last-child');
  
  if (leftColumn && rightColumn) {
    processColumnElements(slide, leftColumn, dom, { x: 0.5, w: 4.5 });
    processColumnElements(slide, rightColumn, dom, { x: 5, w: 4.5 });
  } else if (body.children.length === 2) {
    // 明示的なクラスがない場合、2つの子要素があれば2カラムとして処理
    processColumnElements(slide, body.children[0], dom, { x: 0.5, w: 4.5 });
    processColumnElements(slide, body.children[1], dom, { x: 5, w: 4.5 });
  } else {
    // フォールバック：デフォルトレイアウトとして処理
    processDefaultLayout(slide, body, dom);
  }
}

// カラム要素の処理（改善版）
function processColumnElements(slide: any, column: Element, dom: JSDOM, position: { x: number, w: number }) {
  let currentY = 2;
  
  // AIとは？のような定義ボックス
  const definitionBoxes = column.querySelectorAll('[class*="concept-box"], [class*="definition-box"], .bg-white');
  definitionBoxes.forEach((box) => {
    // 背景ボックスを追加
    slide.addShape('rect', {
      x: position.x,
      y: currentY,
      w: position.w,
      h: 1.5,
      fill: { color: 'FFFFFF' },
      line: { color: 'FFB400', width: 3, dashType: 'solid' },
      shadow: {
        type: 'outer',
        color: '000000',
        blur: 8,
        offset: 2,
        angle: 45,
        opacity: 0.1
      }
    });
    
    // ボックス内のコンテンツ
    const boxTitle = box.querySelector('h3, h2, [class*="title"]');
    const boxText = box.querySelector('p, [class*="text"]');
    
    if (boxTitle) {
      slide.addText(boxTitle.textContent?.trim() || '', {
        x: position.x + 0.2,
        y: currentY + 0.1,
        w: position.w - 0.4,
        h: 0.5,
        fontSize: 20,
        color: '0056B1',
        bold: true,
        fontFace: 'Arial',
      });
    }
    
    if (boxText) {
      slide.addText(boxText.textContent?.trim() || '', {
        x: position.x + 0.2,
        y: currentY + 0.6,
        w: position.w - 0.4,
        h: 0.8,
        fontSize: 14,
        color: '333333',
        fontFace: 'Arial',
        wrap: true,
      });
    }
    
    currentY += 1.8;
  });
  
  // 主要技術リスト
  const techLists = column.querySelectorAll('[class*="tech-list"]');
  techLists.forEach((techList) => {
    const listTitle = techList.querySelector('h3, [class*="title"]');
    if (listTitle) {
      slide.addText(listTitle.textContent?.trim() || '', {
        x: position.x,
        y: currentY,
        w: position.w,
        h: 0.5,
        fontSize: 18,
        color: '0056B1',
        bold: true,
        fontFace: 'Arial',
      });
      currentY += 0.6;
    }
    
    const items = techList.querySelectorAll('li');
    const bulletPoints = Array.from(items).map(item => ({
      text: item.textContent?.trim() || '',
      bullet: { type: 'bullet', color: 'FFB400' }
    }));
    
    if (bulletPoints.length > 0) {
      slide.addText(bulletPoints, {
        x: position.x + 0.2,
        y: currentY,
        w: position.w - 0.4,
        h: bulletPoints.length * 0.4,
        fontSize: 14,
        color: '333333',
        fontFace: 'Arial',
      });
      currentY += bulletPoints.length * 0.4 + 0.5;
    }
  });
  
  // 図表コンテナ（AI円形図など）
  const diagrams = column.querySelectorAll('[class*="diagram-container"], svg');
  diagrams.forEach((diagram) => {
    processSvgDiagram(slide, diagram, dom, position.x, currentY, position.w);
    currentY += 3;
  });
  
  // 未来予測ボックスなど
  const futureBoxes = column.querySelectorAll('[class*="future-box"], [class*="gradient"]');
  futureBoxes.forEach((box) => {
    // グラデーション背景のボックス
    slide.addShape('rect', {
      x: position.x,
      y: currentY,
      w: position.w,
      h: 1.8,
      fill: { color: '0056B1' },
      line: { color: '003d82', width: 0 },
      shadow: {
        type: 'outer',
        color: '000000',
        blur: 12,
        offset: 4,
        angle: 45,
        opacity: 0.3
      }
    });
    
    const boxContent = box.textContent?.trim() || '';
    if (boxContent) {
      slide.addText(boxContent, {
        x: position.x + 0.2,
        y: currentY + 0.2,
        w: position.w - 0.4,
        h: 1.4,
        fontSize: 14,
        color: 'FFFFFF',
        fontFace: 'Arial',
        wrap: true,
      });
    }
    
    currentY += 2;
  });
}

// アイコンの処理
function processIcon(slide: any, icon: Element, dom: JSDOM, x: number, y: number) {
  const iconName = icon.getAttribute('data-icon-name') || '';
  const style = dom.window.getComputedStyle(icon);
  const color = rgbToHex(style.color || '#0066cc');
  
  // Font Awesomeのクラスからアイコンの種類を推定
  const classList = icon.className;
  let shapeType = 'rect';
  
  if (iconName || classList) {
    if (iconName.includes('brain') || classList.includes('fa-brain')) {
      shapeType = 'cloud';
    } else if (iconName.includes('robot') || classList.includes('fa-robot')) {
      shapeType = 'octagon';
    } else if (iconName.includes('microchip') || classList.includes('fa-microchip')) {
      shapeType = 'rect';
    } else if (iconName.includes('cogs') || classList.includes('fa-cogs')) {
      shapeType = 'gear';
    } else if (iconName.includes('network') || classList.includes('fa-network-wired')) {
      shapeType = 'diamond';
    } else if (iconName.includes('comments') || classList.includes('fa-comments')) {
      shapeType = 'ellipse';
    } else if (iconName.includes('eye') || classList.includes('fa-eye')) {
      shapeType = 'ellipse';
    }
  }
  
  slide.addShape(shapeType as any, {
    x: x,
    y: y,
    w: 0.5,
    h: 0.5,
    fill: { color: color },
  });
}

// SVG図表の処理（改善版）
function processSvgDiagram(slide: any, svgContainer: Element, dom: JSDOM, x: number, y: number, maxWidth: number) {
  const svg = svgContainer.tagName === 'SVG' ? svgContainer : svgContainer.querySelector('svg');
  if (!svg) return;
  
  // SVGの寸法を取得
  const viewBox = svg.getAttribute('viewBox');
  let svgWidth = 400;
  let svgHeight = 300;
  
  if (viewBox) {
    const [vx, vy, vw, vh] = viewBox.split(' ').map(Number);
    svgWidth = vw || svgWidth;
    svgHeight = vh || svgHeight;
  } else {
    svgWidth = parseFloat(svg.getAttribute('width') || '400');
    svgHeight = parseFloat(svg.getAttribute('height') || '300');
  }
  
  const scale = Math.min(maxWidth / (svgWidth / 100), 2);
  const scaledWidth = (svgWidth / 100) * scale;
  const scaledHeight = (svgHeight / 100) * scale;
  
  // 背景の矩形を追加（図表のコンテナ）
  slide.addShape('rect', {
    x: x,
    y: y,
    w: scaledWidth,
    h: scaledHeight,
    fill: { color: 'FFFFFF' },
    line: { color: 'E0E0E0', width: 1 },
    shadow: {
      type: 'outer',
      color: '000000',
      blur: 8,
      offset: 2,
      angle: 45,
      opacity: 0.1
    }
  });
  
  // AI中心の円形図の特別処理
  const aiCircle = svg.querySelector('circle[r="120"], circle[r="150"], circle[fill*="4A90E2"]');
  if (aiCircle || svg.innerHTML.includes('AI')) {
    // 中心の大きな円（AI）
    const centerX = x + scaledWidth / 2;
    const centerY = y + scaledHeight / 2;
    const radius = scaledWidth * 0.3;
    
    // グラデーション効果のある円
    slide.addShape('ellipse', {
      x: centerX - radius,
      y: centerY - radius,
      w: radius * 2,
      h: radius * 2,
      fill: { color: '4A90E2' },
      line: { color: '2C5AA0', width: 3, dashType: 'dash' }
    });
    
    // AIテキスト
    slide.addText('AI', {
      x: centerX - radius,
      y: centerY - radius * 0.3,
      w: radius * 2,
      h: radius * 0.6,
      fontSize: 48,
      color: 'FFFFFF',
      bold: true,
      align: 'center',
      fontFace: 'Arial',
    });
    
    // 周囲の要素（学習、推論など）
    const surroundingElements = [
      { text: '学習', angle: 0 },
      { text: '推論', angle: 90 },
      { text: '認識', angle: 180 },
      { text: '理解', angle: 270 }
    ];
    
    surroundingElements.forEach((elem) => {
      const angleRad = (elem.angle * Math.PI) / 180;
      const elemX = centerX + Math.cos(angleRad) * radius * 1.5;
      const elemY = centerY + Math.sin(angleRad) * radius * 1.5;
      const elemSize = radius * 0.5;
      
      // 小さな円
      slide.addShape('ellipse', {
        x: elemX - elemSize / 2,
        y: elemY - elemSize / 2,
        w: elemSize,
        h: elemSize,
        fill: { color: 'FFB400' },
      });
      
      // テキスト
      slide.addText(elem.text, {
        x: elemX - elemSize / 2,
        y: elemY - elemSize / 4,
        w: elemSize,
        h: elemSize / 2,
        fontSize: 16,
        color: 'FFFFFF',
        bold: true,
        align: 'center',
        fontFace: 'Arial',
      });
    });
    
    return; // 特別処理完了
  }
  
  // 通常のSVG要素の処理
  // 円要素
  const circles = svg.querySelectorAll('circle');
  circles.forEach((circle) => {
    const cx = parseFloat(circle.getAttribute('cx') || '0');
    const cy = parseFloat(circle.getAttribute('cy') || '0');
    const r = parseFloat(circle.getAttribute('r') || '0');
    const fill = circle.getAttribute('fill') || '#4A90E2';
    const stroke = circle.getAttribute('stroke');
    
    const circleX = x + (cx / svgWidth) * scaledWidth;
    const circleY = y + (cy / svgHeight) * scaledHeight;
    const circleRadius = (r / Math.max(svgWidth, svgHeight)) * Math.max(scaledWidth, scaledHeight);
    
    const shapeOptions: any = {
      x: circleX - circleRadius,
      y: circleY - circleRadius,
      w: circleRadius * 2,
      h: circleRadius * 2,
      fill: { color: rgbToHex(fill) },
    };
    
    if (stroke) {
      shapeOptions.line = { 
        color: rgbToHex(stroke), 
        width: parseFloat(circle.getAttribute('stroke-width') || '1') 
      };
    }
    
    slide.addShape('ellipse', shapeOptions);
  });
  
  // テキスト要素の処理
  const texts = svg.querySelectorAll('text');
  texts.forEach((text) => {
    const content = text.textContent?.trim() || '';
    if (!content) return;
    
    const tx = parseFloat(text.getAttribute('x') || '0');
    const ty = parseFloat(text.getAttribute('y') || '0');
    const fill = text.getAttribute('fill') || '#000000';
    const fontSize = parseFloat(text.getAttribute('font-size') || '16');
    const textAnchor = text.getAttribute('text-anchor') || 'start';
    
    let align: 'left' | 'center' | 'right' = 'left';
    if (textAnchor === 'middle') align = 'center';
    if (textAnchor === 'end') align = 'right';
    
    const textX = x + (tx / svgWidth) * scaledWidth;
    const textY = y + (ty / svgHeight) * scaledHeight;
    
    slide.addText(content, {
      x: textX - 1, // 調整
      y: textY - 0.3, // 調整
      w: 2,
      h: 0.5,
      fontSize: fontSize * scale,
      color: rgbToHex(fill),
      fontFace: 'Arial',
      align: align,
      bold: parseFloat(text.getAttribute('font-weight') || '400') > 400
    });
  });
  
  // 線要素の処理
  const lines = svg.querySelectorAll('line');
  lines.forEach((line) => {
    const x1 = parseFloat(line.getAttribute('x1') || '0');
    const y1 = parseFloat(line.getAttribute('y1') || '0');
    const x2 = parseFloat(line.getAttribute('x2') || '0');
    const y2 = parseFloat(line.getAttribute('y2') || '0');
    const stroke = line.getAttribute('stroke') || '#000000';
    const strokeWidth = parseFloat(line.getAttribute('stroke-width') || '1');
    
    const lineX1 = x + (x1 / svgWidth) * scaledWidth;
    const lineY1 = y + (y1 / svgHeight) * scaledHeight;
    const lineX2 = x + (x2 / svgWidth) * scaledWidth;
    const lineY2 = y + (y2 / svgHeight) * scaledHeight;
    
    // PowerPointの線は始点と幅・高さで定義される
    slide.addShape('line', {
      x: lineX1,
      y: lineY1,
      w: lineX2 - lineX1,
      h: lineY2 - lineY1,
      line: { 
        color: rgbToHex(stroke), 
        width: strokeWidth * scale,
        dashType: line.getAttribute('stroke-dasharray') ? 'dash' : 'solid'
      },
    });
  });
}

// デフォルトレイアウトの処理
function processDefaultLayout(slide: any, body: Element, dom: JSDOM) {
  // 中央配置でコンテンツを処理
  processColumnElements(slide, body, dom, { x: 1, w: 8 });
}

// グリッドレイアウトの処理
function processGridLayout(slide: any, body: Element, dom: JSDOM) {
  const columns = parseInt(body.getAttribute('data-columns') || '3');
  const items = body.querySelectorAll('.grid-item, > div');
  const itemWidth = 9 / columns;
  
  items.forEach((item, index) => {
    const col = index % columns;
    const row = Math.floor(index / columns);
    const x = 0.5 + col * itemWidth;
    const y = 2 + row * 2;
    
    processColumnElements(slide, item, dom, { x, w: itemWidth - 0.2 });
  });
}

// フッター要素の処理
function processFooterElements(slide: any, footer: Element, dom: JSDOM) {
  const text = footer.textContent?.trim() || '';
  if (text) {
    slide.addText(text, {
      x: 0.5,
      y: 5,
      w: 9,
      h: 0.5,
      fontSize: 10,
      color: '666666',
      align: 'right',
      fontFace: 'Arial',
    });
  }
}

// 背景色を抽出
function extractBackgroundColor(bgValue: string): string | null {
  // グラデーションの場合は最初の色を抽出
  if (bgValue.includes('gradient')) {
    const match = bgValue.match(/#[0-9a-fA-F]{6}|rgb\([^)]+\)/);
    if (match) {
      return rgbToHex(match[0]);
    }
    // デフォルトのグラデーション背景色
    return 'F0F8FF';
  }
  
  // 単色の場合
  if (bgValue && bgValue !== 'none' && bgValue !== 'transparent') {
    return rgbToHex(bgValue);
  }
  
  return null;
}

// RGB色をHEXに変換
function rgbToHex(rgb: string): string {
  // すでにHEX形式の場合
  if (rgb.startsWith('#')) {
    return rgb.substring(1);
  }
  
  // rgb(r, g, b)形式の場合
  const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
  if (match) {
    const r = parseInt(match[1]).toString(16).padStart(2, '0');
    const g = parseInt(match[2]).toString(16).padStart(2, '0');
    const b = parseInt(match[3]).toString(16).padStart(2, '0');
    return r + g + b;
  }
  
  // rgba形式の場合（アルファは無視）
  const rgbaMatch = rgb.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)/);
  if (rgbaMatch) {
    const r = parseInt(rgbaMatch[1]).toString(16).padStart(2, '0');
    const g = parseInt(rgbaMatch[2]).toString(16).padStart(2, '0');
    const b = parseInt(rgbaMatch[3]).toString(16).padStart(2, '0');
    return r + g + b;
  }
  
  // デフォルト色
  return '000000';
} 